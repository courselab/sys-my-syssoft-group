#    SPDX-FileCopyrightText: 2024 reisvictor1 <reisvictor448@gmail.com>
#   
#    SPDX-License-Identifier: GPL-3.0-or-later


Answers:

Questão 1:

Resp: Por conta do PIE do linux, a execução faz com que os endereços da main sejam randômicos.
Dessa forma, há a prevenção para alguns tipos de ataques fazendo com que seja mais difícil
prever os endereços-alvo.

Questão 2:

Primeira execução do código original: 
    input: foo
    output: Access granted.

Segunda execução do código original:
    input: youshallnotpass
    output: Access granted

Por conta da flags e da estrutura do código, é permitido que se faça o input de strings 
maiores que o definido sem emitir erros e sem fazer a verificação.



Para que seja mais robusto, pode se usar a variável 'verified' como retorno da função 'strcmp'.
Assim a função previne que não seja aceito outros inputs além do que seja desejado

Com a flag '-fstack-protector', faz com que a memória seja protegida e não 
deixa que se aloque mais memória para o que foi definida para a varivel 'user_key'

Questao 3:

a) O parâmetro é passado para a função bar através da stack antes desta função
ser chamada. Isso ocorre por conta do padrão da arquitetura x86 e da ABI.

b) O valor da função bar é retornada através do registrador %eax. Isso também
é feito através do padrão da arquitetura x86 e da ABI.

c) As 2 primeiras instruções inicializam uma configuração para preparar a stack 
para as instruções da função e as 2 últimas voltam para sua configuração original. 
Elas organizam e gerenciam a stack para que sigam o padrão da arquitetura x86 e da ABI.

d) A instrução sub prepara um espaço para se alocar as variáveis locais da função na stack
e a instrução da main tem o intuito de alinhar de acordo com a arquitetura x86, ou seja, 
para receber instruções de 16 bytes (ou 128 bits). 

e) Ele colocou a instrução movbsl para converter o retorno de %eax para inteiro.
Declarando a função antes da execução da main permite que essa otimização seja feita.


Questão 4

a) Os 3 programas tiveram o retorno "foo"

~~~> Os três programas executam, mas para o terceiro é preciso informar
     o caminho da lib.

b) Em static, a biblioteca sempre é carregada junto no binário enquanto
dinamico é versionado separadamente e é carregado uma versao diferente do original
e que pode ser compartilhado entre vários componentes.

~~~> E sobre o tamanho, que era a pergunta?

c) Nos dois primeiros, o foo é listado como texto (código), no terceiro
é definido como indefinido. O bar, no primeiro é definido, mas como não
é chamado, no segundo e terceiro não é definido.

~~~> E sobre o significado das colunas (letras), que era a pergunta?

d) Nos dois primeiros, a shared library é só o libc.so.6, enquanto no 
terceiro é usado o libp4.so. Quando o terceiro é compilado, o custom library
é compilado junto ao executavel e é definido como uma flag a ser usado

~~~> O que é "custom library"? Todas as libs, estáticas e dinâmicas são
     compiladas junto com o executável no exemplo.
     E sobre como é acarregada a DLL?

e) No dinâmico, quando o programa deve ser usado em vários hosts, a biblioteca
é compartilhada não precisando ser ocupar o mesmo espaço em todos os hosts;
porém quando é atualizado, os estáticos são melhores são, porque irão compilar
tudo o que foi atualizado em todos os hosts.
Agora quando várias libraries são usadas no mesmo host, dinamicamente irão
compilar exatamente o que é usado para cada executável. Enquanto estaticamente,
todo a biblioteca é compilada no binário de cada executável.

~~~> Os etáticos são melhores no caso de atualização? Como?
     A compilação, novamente, tem a ver com a construção dos binários, não
     com a execução, certo?

~~~>> 1.0